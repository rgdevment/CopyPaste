name: Release Build

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:

permissions:
  contents: write

jobs:
  build:
    runs-on: windows-latest
    timeout-minutes: 30
    strategy:
      matrix:
        arch: [win-x64, win-arm64]
        include:
          - arch: win-x64
            platform: x64
            msvc_arch: x64
            inno_arch: x64
          - arch: win-arm64
            platform: ARM64
            msvc_arch: amd64_arm64
            inno_arch: arm64

    env:
      DOTNET_NOLOGO: true
      DOTNET_CLI_TELEMETRY_OPTOUT: true
      PUBLISH_PATH: CopyPaste.UI/bin/${{ matrix.platform }}/Release/net10.0-windows10.0.22621.0/${{ matrix.arch }}/publish
      PFX_BASE64: ${{ secrets.PFX_BASE64 }}
      PFX_PASSWORD: ${{ secrets.PFX_PASSWORD }}

    steps:
      - uses: actions/checkout@v4

      - name: Wait for CI to start
        shell: pwsh
        run: |
          Start-Sleep -Seconds 30

      - name: Extract version from tag
        id: get_version
        shell: pwsh
        run: |
          if ($env:GITHUB_REF -match 'refs/tags/v(.+)') {
            $version = $matches[1]
          } else {
            $version = "1.0.0"
          }

          if ($version -match '^(\d+\.\d+\.\d+)(?:-(?:alpha|beta|rc)\.(\d+))?$') {
            $baseVersion = $matches[1]
            $preRelease = if ($matches[2]) { $matches[2] } else { "0" }
            $numericVersion = "$baseVersion.$preRelease"
          } else {
            $numericVersion = "$version.0"
          }

          echo "VERSION=$version" >> $env:GITHUB_OUTPUT
          echo "VERSION_NUMERIC=$numericVersion" >> $env:GITHUB_OUTPUT
          echo "Version: $version (numeric: $numericVersion)"

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "10.0.x"
          dotnet-quality: "preview"

      - name: Restore dependencies
        run: dotnet restore CopyPaste.UI/CopyPaste.UI.csproj -r ${{ matrix.arch }} -p:Platform=${{ matrix.platform }}

      - name: Verify CI Status
        shell: pwsh
        run: |
          $sha = git rev-parse HEAD
          Write-Host "ðŸ” Checking CI status for commit: $sha"

          $headers = @{
            "Authorization" = "token ${{ secrets.GITHUB_TOKEN }}"
            "Accept" = "application/vnd.github.v3+json"
          }

          $repo = "${{ github.repository }}"
          $url = "https://api.github.com/repos/$repo/actions/workflows/ci.yml/runs?head_sha=$sha&per_page=1"

          $maxAttempts = 20
          $waitSeconds = 5

          for ($i = 0; $i -lt $maxAttempts; $i++) {
            try {
              $response = Invoke-RestMethod -Uri $url -Headers $headers -ErrorAction Stop
            } catch {
              Write-Warning "API call failed: $($_.Exception.Message)"
              Start-Sleep -Seconds $waitSeconds
              continue
            }

            if ($response.total_count -eq 0) {
              if ($i -eq 0) {
                Write-Host "No CI run found for this SHA, checking if already validated..."
              }
              if ($i -ge 3) {
                Write-Host "No CI run found â€” commit was likely already validated on main."
                exit 0
              }
              Start-Sleep -Seconds $waitSeconds
              continue
            }

            $run = $response.workflow_runs[0]
            $status = $run.status
            $conclusion = $run.conclusion
            Write-Host "ðŸ“Š CI run #$($run.run_number) â€” Status: $status, Conclusion: $conclusion"

            if ($status -eq "completed") {
              if ($conclusion -eq "success") {
                Write-Host "âœ… CI passed successfully!"
                exit 0
              } else {
                Write-Error "âŒ CI failed with conclusion: $conclusion"
                Write-Host "::error::CI failed â€” Release blocked"
                exit 1
              }
            }

            $elapsed = ($i + 1) * $waitSeconds
            Write-Host "â³ CI is still running... ($elapsed seconds elapsed, attempt $($i + 1)/$maxAttempts)"
            Start-Sleep -Seconds $waitSeconds
          }

          Write-Warning "âš ï¸  CI verification timed out. Proceeding â€” please verify manually."


      - name: Lint (Check format)
        run: dotnet format CopyPaste.UI/CopyPaste.UI.csproj --verify-no-changes --no-restore

      - name: Setup MSVC
        uses: ilammy/msvc-dev-cmd@v1
        with:
          arch: ${{ matrix.msvc_arch }}

      - name: Build Native Launcher
        shell: pwsh
        run: |
          Push-Location CopyPaste.Launcher
          rc.exe /fo resources.res resources.rc
          cl.exe /O2 /MT /EHsc main.cpp resources.res `
            /link user32.lib gdi32.lib gdiplus.lib shell32.lib `
            /OUT:CopyPaste.exe `
            /SUBSYSTEM:WINDOWS `
            /MANIFEST:EMBED `
            /MANIFESTINPUT:app.manifest
          if ($LASTEXITCODE -ne 0) { exit 1 }
          Pop-Location

      - name: Publish (${{ matrix.arch }})
        shell: pwsh
        run: |
          $v = "${{ steps.get_version.outputs.VERSION }}"
          $vn = "${{ steps.get_version.outputs.VERSION_NUMERIC }}"

          dotnet publish CopyPaste.UI/CopyPaste.UI.csproj `
            -c Release `
            -r ${{ matrix.arch }} `
            -p:Platform=${{ matrix.platform }} `
            -p:Version=$v `
            -p:AssemblyVersion=$vn `
            -p:FileVersion=$vn `
            --self-contained true `
            -p:DebugType=None `
            -p:DebugSymbols=false `
            -p:PublishReadyToRun=true `
            -p:PublishReadyToRunComposite=true `
            -p:PublishTrimmed=true `
            -p:TrimMode=partial `
            -p:TieredCompilation=true `
            -p:TieredCompilationQuickJitForLoops=true `
            --no-restore

          if ($LASTEXITCODE -ne 0) { exit 1 }

          $expectedPath = "${{ env.PUBLISH_PATH }}"
          if (-not (Test-Path $expectedPath)) {
            Write-Error "Publish output not found at: $expectedPath"
            exit 1
          }

      - name: Integrate Native Launcher
        shell: pwsh
        run: |
          $publishDir = (Resolve-Path "${{ env.PUBLISH_PATH }}").Path
          Copy-Item "CopyPaste.Launcher/CopyPaste.exe" -Destination $publishDir

      - name: Clean Publish Output
        shell: pwsh
        run: |
          $publishDir = (Resolve-Path "${{ env.PUBLISH_PATH }}").Path
          $keepFolders = @('Assets', 'Microsoft.UI.Xaml', 'NpuDetect', 'en-us', 'en-US', 'en')

          Get-ChildItem -Path $publishDir -Directory | Where-Object {
            ($keepFolders -notcontains $_.Name) -and
            ($_.Name -match '^[a-z]{2,3}(-[A-Za-z]{2,8})?(-[A-Za-z]{2,8})?$')
          } | Remove-Item -Recurse -Force

          Get-ChildItem -Path $publishDir -Filter "*.pdb" -Recurse | Remove-Item -Force
          Get-ChildItem -Path $publishDir -Filter "*.xml" -Recurse | Where-Object {
            $_.Name -notlike "*.resources.xml"
          } | Remove-Item -Force
          Get-ChildItem -Path $publishDir -Filter "createdump.exe" -Recurse | Remove-Item -Force

          $sizeBytes = (Get-ChildItem -Path $publishDir -File -Recurse | Measure-Object -Property Length -Sum).Sum
          Write-Host "Publish output: $([math]::Round($sizeBytes / 1MB, 2)) MB"

      - name: Decode signing certificate
        if: env.PFX_BASE64 != ''
        shell: pwsh
        run: |
          $bytes = [Convert]::FromBase64String($env:PFX_BASE64)
          Set-Content -Path signingCert.pfx -Value $bytes -AsByteStream

      - name: Sign App Binaries
        if: env.PFX_BASE64 != ''
        shell: pwsh
        run: |
          $pfxPath = Join-Path $PWD 'signingCert.pfx'
          $signtool = Get-ChildItem -Path "C:\Program Files (x86)\Windows Kits\10\bin" -Recurse -Filter "signtool.exe" | Where-Object { $_.FullName -like "*x64*" } | Sort-Object FullName -Descending | Select-Object -First 1
          if (-not $signtool) { Write-Error "Signtool not found"; exit 1 }

          $targetDir = (Resolve-Path "${{ env.PUBLISH_PATH }}").Path
          Get-ChildItem -Path $targetDir -Include *.exe,*.dll -Recurse | ForEach-Object {
            & $signtool.FullName sign /f $pfxPath /p $env:PFX_PASSWORD /tr http://timestamp.digicert.com /td sha256 /fd sha256 $_.FullName
          }

      - name: Install Inno Setup
        run: choco install innosetup --no-progress

      - name: Build Installer
        shell: pwsh
        run: |
          $iscc = "C:\Program Files (x86)\Inno Setup 6\ISCC.exe"

          $fullPath = Join-Path "${{ github.workspace }}" "${{ env.PUBLISH_PATH }}"
          $publishDir = (Resolve-Path $fullPath).Path

          $repoRoot = "${{ github.workspace }}"
          $myArch = "${{ matrix.inno_arch }}"
          $version = "${{ steps.get_version.outputs.VERSION }}"
          $versionNumeric = "${{ steps.get_version.outputs.VERSION_NUMERIC }}"

          & $iscc setup.iss "/DPublishDir=$publishDir" "/DMyArch=$myArch" "/DMyAppVersion=$version" "/DMyAppVersionNumeric=$versionNumeric" "/DRepoRoot=$repoRoot"

      - name: Rename Installer
        shell: pwsh
        run: |
          $arch = "${{ matrix.inno_arch }}"
          Move-Item -Path "Output/CopyPaste_Setup_$arch.exe" -Destination "CopyPaste-${{ steps.get_version.outputs.VERSION }}-${{ matrix.arch }}-setup.exe"

      - name: Sign Installer
        if: env.PFX_BASE64 != ''
        shell: pwsh
        run: |
          $pfxPath = Join-Path $PWD 'signingCert.pfx'
          $signtool = Get-ChildItem -Path "C:\Program Files (x86)\Windows Kits\10\bin" -Recurse -Filter "signtool.exe" | Where-Object { $_.FullName -like "*x64*" } | Sort-Object FullName -Descending | Select-Object -First 1
          & $signtool.FullName sign /f $pfxPath /p $env:PFX_PASSWORD /tr http://timestamp.digicert.com /td sha256 /fd sha256 "CopyPaste-${{ steps.get_version.outputs.VERSION }}-${{ matrix.arch }}-setup.exe"

      - name: Upload installer artifact
        uses: actions/upload-artifact@v4
        with:
          name: installer-${{ matrix.arch }}
          path: CopyPaste-${{ steps.get_version.outputs.VERSION }}-${{ matrix.arch }}-setup.exe
          retention-days: 5

  # â”€â”€â”€ GitHub Release â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  release:
    runs-on: ubuntu-latest
    needs: build
    timeout-minutes: 10
    if: startsWith(github.ref, 'refs/tags/')

    steps:
      - name: Download all installer artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: installer-*
          path: installers
          merge-multiple: true

      - name: List installers
        run: ls -lh installers/

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          generate_release_notes: true
          files: installers/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # â”€â”€â”€ Microsoft Store MSIX Build â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  store:
    runs-on: windows-latest
    needs: release
    timeout-minutes: 30
    if: startsWith(github.ref, 'refs/tags/v') && !contains(github.ref, '-')
    strategy:
      matrix:
        include:
          - platform: x64
            msix_arch: x64
          - platform: ARM64
            msix_arch: arm64

    env:
      DOTNET_NOLOGO: true
      DOTNET_CLI_TELEMETRY_OPTOUT: true

    steps:
      - uses: actions/checkout@v4

      - name: Extract version from tag
        id: get_version
        shell: pwsh
        run: |
          if ($env:GITHUB_REF -match 'refs/tags/v(.+)') {
            $version = $matches[1]
          } else {
            $version = "1.0.0"
          }

          if ($version -match '^(\d+\.\d+\.\d+)') {
            $numericVersion = "$($matches[1]).0"
          } else {
            $numericVersion = "$version.0"
          }

          echo "VERSION=$version" >> $env:GITHUB_OUTPUT
          echo "VERSION_NUMERIC=$numericVersion" >> $env:GITHUB_OUTPUT
          Write-Host "Version: $version (Store: $numericVersion)"

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "10.0.x"
          dotnet-quality: "preview"

      - name: Update Package.appxmanifest
        shell: pwsh
        run: |
          $path = "CopyPaste.UI/Package.appxmanifest"
          [xml]$xml = Get-Content $path
          $ns = New-Object System.Xml.XmlNamespaceManager($xml.NameTable)
          $ns.AddNamespace("pkg", "http://schemas.microsoft.com/appx/manifest/foundation/windows10")

          $identity = $xml.SelectSingleNode("//pkg:Identity", $ns)
          $identity.SetAttribute("Version", "${{ steps.get_version.outputs.VERSION_NUMERIC }}")
          $identity.SetAttribute("ProcessorArchitecture", "${{ matrix.msix_arch }}")
          $xml.Save((Resolve-Path $path).Path)

          Write-Host "Updated manifest: Version=${{ steps.get_version.outputs.VERSION_NUMERIC }}, Arch=${{ matrix.msix_arch }}"

      - name: Restore dependencies
        run: dotnet restore CopyPaste.UI/CopyPaste.UI.csproj -p:PackageMode=Store -p:Platform=${{ matrix.platform }}

      - name: Build MSIX package
        shell: pwsh
        run: |
          $v = "${{ steps.get_version.outputs.VERSION }}"
          $vn = "${{ steps.get_version.outputs.VERSION_NUMERIC }}"

          dotnet build CopyPaste.UI/CopyPaste.UI.csproj `
            -c Release `
            -p:PackageMode=Store `
            -p:Platform=${{ matrix.platform }} `
            -p:Version=$v `
            -p:AssemblyVersion=$vn `
            -p:FileVersion=$vn `
            -p:AppxBundle=Never `
            -p:UapAppxPackageBuildMode=StoreUpload `
            -p:AppxPackageSigningEnabled=false `
            --no-restore

          if ($LASTEXITCODE -ne 0) { exit 1 }

      - name: Locate MSIX output
        id: msix
        shell: pwsh
        run: |
          # Look for .msixupload first (preferred for Store), then .msix
          $file = Get-ChildItem -Path "CopyPaste.UI" -Recurse -Include "*.msixupload" |
                  Select-Object -First 1

          if (-not $file) {
            $file = Get-ChildItem -Path "CopyPaste.UI" -Recurse -Include "*.msix" |
                    Select-Object -First 1
          }

          if (-not $file) {
            Write-Error "No MSIX output found"
            exit 1
          }

          $ext = $file.Extension
          $cleanName = "CopyPaste-${{ steps.get_version.outputs.VERSION }}-${{ matrix.msix_arch }}$ext"
          $cleanPath = Join-Path $file.Directory.FullName $cleanName
          Copy-Item $file.FullName $cleanPath

          echo "PATH=$cleanPath" >> $env:GITHUB_OUTPUT
          echo "NAME=$cleanName" >> $env:GITHUB_OUTPUT

      - name: Upload MSIX artifact
        uses: actions/upload-artifact@v4
        with:
          name: msix-${{ matrix.msix_arch }}
          path: ${{ steps.msix.outputs.PATH }}
          retention-days: 30

      - name: Attach MSIX to GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          files: ${{ steps.msix.outputs.PATH }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # â”€â”€â”€ Microsoft Store Submission â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  store-publish:
    runs-on: windows-latest
    needs: store
    timeout-minutes: 15
    if: startsWith(github.ref, 'refs/tags/v') && !contains(github.ref, '-')

    env:
      STORE_TENANT_ID: ${{ secrets.STORE_TENANT_ID }}
      STORE_CLIENT_ID: ${{ secrets.STORE_CLIENT_ID }}
      STORE_CLIENT_SECRET: ${{ secrets.STORE_CLIENT_SECRET }}

    steps:
      - name: Check Store credentials
        id: check_creds
        shell: pwsh
        run: |
          if ([string]::IsNullOrEmpty($env:STORE_TENANT_ID) -or
              [string]::IsNullOrEmpty($env:STORE_CLIENT_ID) -or
              [string]::IsNullOrEmpty($env:STORE_CLIENT_SECRET)) {
            Write-Host "Store credentials not configured - skipping"
            echo "HAS_CREDS=false" >> $env:GITHUB_OUTPUT
          } else {
            echo "HAS_CREDS=true" >> $env:GITHUB_OUTPUT
          }

      - name: Extract version from tag
        if: steps.check_creds.outputs.HAS_CREDS == 'true'
        id: get_version
        shell: pwsh
        run: |
          if ($env:GITHUB_REF -match 'refs/tags/v(.+)') {
            $version = $matches[1]
          } else {
            $version = "1.0.0"
          }
          echo "VERSION=$version" >> $env:GITHUB_OUTPUT

      - name: Get release notes from GitHub Release
        if: steps.check_creds.outputs.HAS_CREDS == 'true'
        id: release_notes
        shell: pwsh
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          $tag = "v${{ steps.get_version.outputs.VERSION }}"
          $headers = @{
            "Authorization" = "token $env:GH_TOKEN"
            "Accept" = "application/vnd.github.v3+json"
          }

          try {
            $release = Invoke-RestMethod `
              -Uri "https://api.github.com/repos/${{ github.repository }}/releases/tags/$tag" `
              -Headers $headers

            $body = $release.body
            if ([string]::IsNullOrWhiteSpace($body)) {
              $body = "Bug fixes and improvements."
            }

            if ($body.Length -gt 1500) {
              $body = $body.Substring(0, 1497) + "..."
            }

            $delimiter = "RELEASE_NOTES_EOF"
            echo "NOTES<<$delimiter" >> $env:GITHUB_OUTPUT
            echo $body >> $env:GITHUB_OUTPUT
            echo $delimiter >> $env:GITHUB_OUTPUT
            Write-Host "Release notes extracted ($($body.Length) chars)"
          } catch {
            Write-Warning "Failed to fetch release notes: $($_.Exception.Message)"
            echo "NOTES=Bug fixes and improvements." >> $env:GITHUB_OUTPUT
          }

      - name: Download MSIX packages
        if: steps.check_creds.outputs.HAS_CREDS == 'true'
        uses: actions/download-artifact@v4
        with:
          pattern: msix-*
          path: packages
          merge-multiple: true

      - name: Setup .NET
        if: steps.check_creds.outputs.HAS_CREDS == 'true'
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "10.0.x"
          dotnet-quality: "preview"

      - name: Install Microsoft Store CLI
        if: steps.check_creds.outputs.HAS_CREDS == 'true'
        run: dotnet tool install -g MSStore.CLI

      - name: Configure Store CLI
        if: steps.check_creds.outputs.HAS_CREDS == 'true'
        shell: pwsh
        run: |
          msstore reconfigure `
            --tenantId $env:STORE_TENANT_ID `
            --clientId $env:STORE_CLIENT_ID `
            --clientSecret $env:STORE_CLIENT_SECRET

      - name: Upload packages (without committing)
        if: steps.check_creds.outputs.HAS_CREDS == 'true'
        shell: pwsh
        run: |
          $packages = Get-ChildItem -Path packages -Include "*.msixupload","*.msix" -Recurse
          if ($packages.Count -eq 0) {
            Write-Error "No MSIX packages found"
            exit 1
          }

          $firstPackage = $packages[0].FullName
          msstore publish $firstPackage --inputDirectory packages --appId ${{ vars.STORE_APP_ID }} --noCommit --verbose

      - name: Update Store listing with release notes
        if: steps.check_creds.outputs.HAS_CREDS == 'true'
        shell: pwsh
        env:
          RELEASE_NOTES: ${{ steps.release_notes.outputs.NOTES }}
        run: |
          $appId = "${{ vars.STORE_APP_ID }}"
          $notes = $env:RELEASE_NOTES

          if ([string]::IsNullOrWhiteSpace($notes)) {
            $notes = "Bug fixes and improvements."
          }

          # Strip Markdown formatting for clean Store listing
          $notes = $notes -replace '\r\n', "`n"
          $notes = $notes -replace '#{1,6}\s+', ''
          $notes = $notes -replace '\*\*([^*]+)\*\*', '$1'
          $notes = $notes -replace '\*([^*]+)\*', '$1'
          $notes = $notes -replace '`([^`]+)`', '$1'
          $notes = $notes -replace '\[([^\]]+)\]\([^\)]+\)', '$1'
          $notes = $notes -replace '(?m)^- ', 'â€¢ '

          $metadata = @{
            Listings = @{
              "en-us" = @{
                BaseListing = @{
                  ReleaseNotes = $notes
                }
              }
            }
          }

          $metadataJson = $metadata | ConvertTo-Json -Depth 5 -Compress
          Write-Host "Store metadata: $metadataJson"
          msstore submission updateMetadata $appId $metadataJson --skipInitialPolling

      - name: Commit and publish submission
        if: steps.check_creds.outputs.HAS_CREDS == 'true'
        shell: pwsh
        run: |
          msstore submission publish ${{ vars.STORE_APP_ID }}
