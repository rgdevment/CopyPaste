name: Release Build

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:

permissions:
  contents: write

jobs:
  release:
    runs-on: windows-latest
    timeout-minutes: 30
    strategy:
      matrix:
        arch: [win-x64, win-arm64]
        include:
          - arch: win-x64
            platform: x64
            msvc_arch: x64
            inno_arch: x64
          - arch: win-arm64
            platform: ARM64
            msvc_arch: amd64_arm64
            inno_arch: arm64

    env:
      DOTNET_NOLOGO: true
      DOTNET_CLI_TELEMETRY_OPTOUT: true
      PUBLISH_PATH: CopyPaste.UI/bin/${{ matrix.platform }}/Release/net10.0-windows10.0.22621.0/${{ matrix.arch }}/publish
      PFX_BASE64: ${{ secrets.PFX_BASE64 }}
      PFX_PASSWORD: ${{ secrets.PFX_PASSWORD }}

    steps:
      - uses: actions/checkout@v4

      - name: Wait for CI to start
        shell: pwsh
        run: |
          Write-Host "â³ Waiting 30 seconds to ensure CI workflow starts first..."
          Write-Host "This prevents race conditions where release starts before CI"
          Start-Sleep -Seconds 30
          Write-Host "âœ… Wait complete, proceeding with release verification"

      - name: Extract version from tag
        id: get_version
        shell: pwsh
        run: |
          if ($env:GITHUB_REF -match 'refs/tags/v(.+)') {
            $version = $matches[1]
          } else {
            $version = "1.0.0"
          }

          # Extract numeric version for Windows (e.g., 1.0.0-beta.1 -> 1.0.0.1)
          if ($version -match '^(\d+\.\d+\.\d+)(?:-(?:alpha|beta|rc)\.(\d+))?$') {
            $baseVersion = $matches[1]
            $preRelease = if ($matches[2]) { $matches[2] } else { "0" }
            $numericVersion = "$baseVersion.$preRelease"
          } else {
            $numericVersion = "$version.0"
          }

          echo "VERSION=$version" >> $env:GITHUB_OUTPUT
          echo "VERSION_NUMERIC=$numericVersion" >> $env:GITHUB_OUTPUT
          echo "Version: $version (numeric: $numericVersion)"

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "10.0.x"
          dotnet-quality: "preview"

      - name: Restore dependencies
        run: dotnet restore CopyPaste.UI/CopyPaste.UI.csproj -r ${{ matrix.arch }} -p:Platform=${{ matrix.platform }}

      - name: Verify CI Status
        shell: pwsh
        run: |
          $sha = git rev-parse HEAD
          Write-Host "ðŸ” Checking CI status for commit: $sha"

          # Get the CI workflow runs for this commit
          $headers = @{
            "Authorization" = "token ${{ secrets.GITHUB_TOKEN }}"
            "Accept" = "application/vnd.github.v3+json"
          }

          $repo = "${{ github.repository }}"
          $url = "https://api.github.com/repos/$repo/commits/$sha/check-runs"

          # Configuration
          $maxWaitAttempts = 30  # Wait up to 5 minutes for CI to complete
          $maxRetries = 3        # Retry up to 3 times if API fails
          $waitSeconds = 10
          $ciPassed = $false

          function Test-CIStatus {
            param($retryCount = 0)

            try {
              $attempt = 0

              while ($attempt -lt $maxWaitAttempts) {
                $response = Invoke-RestMethod -Uri $url -Headers $headers -ErrorAction Stop
                $ciRuns = $response.check_runs | Where-Object {
                  $_.name -like "*CI*" -or
                  $_.name -like "*Build*Test*" -or
                  $_.name -like "*build*"
                }

                if ($ciRuns.Count -eq 0) {
                  Write-Host "âš ï¸  No CI runs found yet. Waiting... (attempt $($attempt + 1)/$maxWaitAttempts)"
                  Start-Sleep -Seconds $waitSeconds
                  $attempt++
                  continue
                }

                $latestCi = $ciRuns | Sort-Object -Property started_at -Descending | Select-Object -First 1
                $status = $latestCi.status
                $conclusion = $latestCi.conclusion
                $ciName = $latestCi.name

                Write-Host "ðŸ“Š CI '$ciName' - Status: $status, Conclusion: $conclusion"

                if ($status -eq "completed") {
                  if ($conclusion -eq "success") {
                    Write-Host "âœ… CI passed successfully!"
                    return $true
                  } else {
                    Write-Error "âŒ CI failed with conclusion: $conclusion"
                    Write-Error "Cannot proceed with release. Please fix CI issues first."
                    Write-Host "::error::CI failed - Release blocked"
                    exit 1
                  }
                } else {
                  $elapsed = $attempt * $waitSeconds
                  Write-Host "â³ CI is still running... ($elapsed seconds elapsed, attempt $($attempt + 1)/$maxWaitAttempts)"
                  Start-Sleep -Seconds $waitSeconds
                  $attempt++
                }
              }

              # Timeout reached
              Write-Warning "âš ï¸  CI verification timed out after $($maxWaitAttempts * $waitSeconds) seconds"
              Write-Warning "Proceeding with caution. Please verify CI status manually."
              return $true

            } catch {
              if ($retryCount -lt $maxRetries) {
                $nextRetry = $retryCount + 1
                Write-Warning "âš ï¸  API call failed (attempt $nextRetry/$maxRetries): $($_.Exception.Message)"
                Write-Host "Retrying in 5 seconds..."
                Start-Sleep -Seconds 5
                return Test-CIStatus -retryCount $nextRetry
              } else {
                Write-Error "âŒ Failed to verify CI status after $maxRetries retries"
                Write-Error "Last error: $($_.Exception.Message)"
                Write-Warning "Proceeding with caution - could not verify CI status"
                return $true
              }
            }
          }

          $ciPassed = Test-CIStatus

          if (-not $ciPassed) {
            Write-Error "âŒ CI verification failed. Release aborted."
            exit 1
          }

          Write-Host "âœ… CI verification complete - proceeding with release"


      - name: Lint (Check format)
        run: dotnet format CopyPaste.UI/CopyPaste.UI.csproj --verify-no-changes --no-restore

      - name: Setup MSVC
        uses: ilammy/msvc-dev-cmd@v1
        with:
          arch: ${{ matrix.msvc_arch }}

      - name: Build Native Launcher
        shell: pwsh
        run: |
          Write-Host "ðŸ”¨ Building native C++ launcher..."
          Push-Location CopyPaste.Launcher

          # Compile resource file (icon)
          rc.exe /fo resources.res resources.rc

          # Compile with optimizations, embed manifest and icon
          cl.exe /O2 /MT /EHsc main.cpp resources.res `
            /link user32.lib gdi32.lib gdiplus.lib shell32.lib `
            /OUT:CopyPaste.exe `
            /SUBSYSTEM:WINDOWS `
            /MANIFEST:EMBED `
            /MANIFESTINPUT:app.manifest

          if ($LASTEXITCODE -ne 0) {
            Write-Error "Failed to build native launcher"
            exit 1
          }

          Pop-Location
          Write-Host "âœ… Native launcher built successfully"

      - name: Publish (${{ matrix.arch }})
        shell: pwsh
        run: |
          dotnet publish CopyPaste.UI/CopyPaste.UI.csproj `
            -c Release `
            -r ${{ matrix.arch }} `
            -p:Platform=${{ matrix.platform }} `
            --self-contained true `
            -p:DebugType=None `
            -p:DebugSymbols=false `
            -p:PublishReadyToRun=true `
            -p:PublishReadyToRunComposite=true `
            -p:PublishTrimmed=true `
            -p:TrimMode=partial `
            -p:TieredCompilation=true `
            -p:TieredCompilationQuickJitForLoops=true `
            --no-restore

          if ($LASTEXITCODE -ne 0) {
            Write-Error "dotnet publish failed"
            exit 1
          }

          # Verify publish output exists
          $expectedPath = "${{ env.PUBLISH_PATH }}"
          if (Test-Path $expectedPath) {
            Write-Host "âœ… Publish output found at: $expectedPath"
            Get-ChildItem $expectedPath -Name | Select-Object -First 10
          } else {
            Write-Error "âŒ Publish output not found at: $expectedPath"
            Write-Host "Searching for publish folders..."
            Get-ChildItem -Path "CopyPaste.UI/bin" -Recurse -Directory -Filter "publish" | ForEach-Object { Write-Host $_.FullName }
            exit 1
          }

      - name: Integrate Native Launcher
        shell: pwsh
        run: |
          $publishDir = (Resolve-Path "${{ env.PUBLISH_PATH }}").Path

          # Copy native launcher to publish directory (overwrites the .NET exe name)
          Copy-Item "CopyPaste.Launcher/CopyPaste.exe" -Destination $publishDir

          Write-Host "âœ… Native launcher integrated"
          Write-Host "Entry point: CopyPaste.exe (native launcher)"
          Write-Host ".NET app: CopyPaste.App.exe"

      - name: Clean Publish Output
        shell: pwsh
        run: |
          $publishDir = (Resolve-Path "${{ env.PUBLISH_PATH }}").Path
          Write-Host "Cleaning publish directory: $publishDir"

          # Define folders to keep (exact names)
          $keepFolders = @('Assets', 'Microsoft.UI.Xaml', 'NpuDetect', 'en-us', 'en-US', 'en')

          # Remove all culture/language folders except essential ones
          # Pattern matches: xx, xx-XX, xx-Xxxx-XX, xxx-XX (culture codes including variants)
          Get-ChildItem -Path $publishDir -Directory | Where-Object {
            $folderName = $_.Name
            ($keepFolders -notcontains $folderName) -and
            ($folderName -match '^[a-z]{2,3}(-[A-Za-z]{2,8})?(-[A-Za-z]{2,8})?$')
          } | ForEach-Object {
            Write-Host "Removing culture folder: $($_.Name)"
            Remove-Item -Path $_.FullName -Recurse -Force
          }

          # Remove PDB files
          Get-ChildItem -Path $publishDir -Filter "*.pdb" -Recurse | Remove-Item -Force

          # Remove XML documentation files (except resources)
          Get-ChildItem -Path $publishDir -Filter "*.xml" -Recurse | Where-Object {
            $_.Name -notlike "*.resources.xml"
          } | Remove-Item -Force

          # Remove createdump.exe (crash dump tool, not needed for production)
          Get-ChildItem -Path $publishDir -Filter "createdump.exe" -Recurse | Remove-Item -Force

          # Count and display results
          $fileCount = (Get-ChildItem -Path $publishDir -File -Recurse).Count
          $folderCount = (Get-ChildItem -Path $publishDir -Directory -Recurse).Count
          $sizeBytes = (Get-ChildItem -Path $publishDir -File -Recurse | Measure-Object -Property Length -Sum).Sum
          $sizeMB = [math]::Round($sizeBytes / 1MB, 2)

          Write-Host "Final publish output: $fileCount files, $folderCount folders, $sizeMB MB"
          Get-ChildItem -Path $publishDir -Directory | Select-Object Name | Format-Table

      - name: Decode signing certificate
        if: env.PFX_BASE64 != ''
        shell: pwsh
        run: |
          $bytes = [Convert]::FromBase64String($env:PFX_BASE64)
          Set-Content -Path signingCert.pfx -Value $bytes -AsByteStream

      - name: Sign App Binaries
        if: env.PFX_BASE64 != ''
        shell: pwsh
        run: |
          $pfxPath = Join-Path $PWD 'signingCert.pfx'

          # Find latest x64 version of signtool
          $signtool = Get-ChildItem -Path "C:\Program Files (x86)\Windows Kits\10\bin" -Recurse -Filter "signtool.exe" | Where-Object { $_.FullName -like "*x64*" } | Sort-Object FullName -Descending | Select-Object -First 1

          if (-not $signtool) { Write-Error "Signtool not found"; exit 1 }
          Write-Host "Using Signtool: $($signtool.FullName)"

          $targetDir = (Resolve-Path "${{ env.PUBLISH_PATH }}").Path
          Get-ChildItem -Path $targetDir -Include *.exe,*.dll -Recurse | ForEach-Object {
            & $signtool.FullName sign /f $pfxPath /p $env:PFX_PASSWORD /tr http://timestamp.digicert.com /td sha256 /fd sha256 $_.FullName
          }

      - name: Install Inno Setup
        run: choco install innosetup --no-progress

      - name: Build Installer
        shell: pwsh
        run: |
          $iscc = "C:\Program Files (x86)\Inno Setup 6\ISCC.exe"

          $fullPath = Join-Path "${{ github.workspace }}" "${{ env.PUBLISH_PATH }}"
          $publishDir = (Resolve-Path $fullPath).Path

          $repoRoot = "${{ github.workspace }}"
          $myArch = "${{ matrix.inno_arch }}"
          $version = "${{ steps.get_version.outputs.VERSION }}"
          $versionNumeric = "${{ steps.get_version.outputs.VERSION_NUMERIC }}"

          Write-Host "Building installer with:"
          Write-Host "Source: $publishDir"
          Write-Host "Arch: $myArch"
          Write-Host "Version: $version (numeric: $versionNumeric)"

          & $iscc setup.iss "/DPublishDir=$publishDir" "/DMyArch=$myArch" "/DMyAppVersion=$version" "/DMyAppVersionNumeric=$versionNumeric" "/DRepoRoot=$repoRoot"

      - name: Rename Installer
        shell: pwsh
        run: |
          $arch = "${{ matrix.inno_arch }}"
          Move-Item -Path "Output/CopyPaste_Setup_$arch.exe" -Destination "CopyPaste-${{ steps.get_version.outputs.VERSION }}-${{ matrix.arch }}-setup.exe"

      - name: Sign Installer
        if: env.PFX_BASE64 != ''
        shell: pwsh
        run: |
          $pfxPath = Join-Path $PWD 'signingCert.pfx'

          # Find latest x64 version of signtool
          $signtool = Get-ChildItem -Path "C:\Program Files (x86)\Windows Kits\10\bin" -Recurse -Filter "signtool.exe" | Where-Object { $_.FullName -like "*x64*" } | Sort-Object FullName -Descending | Select-Object -First 1

          & $signtool.FullName sign /f $pfxPath /p $env:PFX_PASSWORD /tr http://timestamp.digicert.com /td sha256 /fd sha256 "CopyPaste-${{ steps.get_version.outputs.VERSION }}-${{ matrix.arch }}-setup.exe"

      - name: Release Files
        uses: softprops/action-gh-release@v2
        if: startsWith(github.ref, 'refs/tags/')
        with:
          generate_release_notes: true
          files: |
            CopyPaste-${{ steps.get_version.outputs.VERSION }}-${{ matrix.arch }}-setup.exe
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # â”€â”€â”€ Microsoft Store MSIX Build â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Builds MSIX packages for Store distribution (x64 + ARM64).
  # Runs after standalone release succeeds (ensures CI is green).
  # MSIX packages are attached to the GitHub Release for manual upload
  # and passed to store-publish for automated submission.
  store:
    runs-on: windows-latest
    needs: release
    timeout-minutes: 30
    if: startsWith(github.ref, 'refs/tags/v') && !contains(github.ref, '-')
    strategy:
      matrix:
        include:
          - platform: x64
            msix_arch: x64
          - platform: ARM64
            msix_arch: arm64

    env:
      DOTNET_NOLOGO: true
      DOTNET_CLI_TELEMETRY_OPTOUT: true

    steps:
      - uses: actions/checkout@v4

      - name: Extract version from tag
        id: get_version
        shell: pwsh
        run: |
          if ($env:GITHUB_REF -match 'refs/tags/v(.+)') {
            $version = $matches[1]
          } else {
            $version = "1.0.0"
          }

          # Store only runs on stable tags (no pre-release).
          # Microsoft Store requires revision (4th component) to be 0.
          # Stable version: Major.Minor.Patch.0
          if ($version -match '^(\d+\.\d+\.\d+)') {
            $numericVersion = "$($matches[1]).0"
          } else {
            $numericVersion = "$version.0"
          }

          echo "VERSION=$version" >> $env:GITHUB_OUTPUT
          echo "VERSION_NUMERIC=$numericVersion" >> $env:GITHUB_OUTPUT
          Write-Host "Version: $version (Store: $numericVersion)"

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "10.0.x"
          dotnet-quality: "preview"

      - name: Update Package.appxmanifest
        shell: pwsh
        run: |
          $path = "CopyPaste.UI/Package.appxmanifest"
          [xml]$xml = Get-Content $path
          $ns = New-Object System.Xml.XmlNamespaceManager($xml.NameTable)
          $ns.AddNamespace("pkg", "http://schemas.microsoft.com/appx/manifest/foundation/windows10")

          $identity = $xml.SelectSingleNode("//pkg:Identity", $ns)
          $identity.SetAttribute("Version", "${{ steps.get_version.outputs.VERSION_NUMERIC }}")
          $identity.SetAttribute("ProcessorArchitecture", "${{ matrix.msix_arch }}")
          $xml.Save((Resolve-Path $path).Path)

          Write-Host "Updated manifest: Version=${{ steps.get_version.outputs.VERSION_NUMERIC }}, Arch=${{ matrix.msix_arch }}"

      - name: Restore dependencies
        run: dotnet restore CopyPaste.UI/CopyPaste.UI.csproj -p:PackageMode=Store -p:Platform=${{ matrix.platform }}

      - name: Build MSIX package
        shell: pwsh
        run: |
          dotnet build CopyPaste.UI/CopyPaste.UI.csproj `
            -c Release `
            -p:PackageMode=Store `
            -p:Platform=${{ matrix.platform }} `
            -p:AppxBundle=Never `
            -p:UapAppxPackageBuildMode=StoreUpload `
            -p:AppxPackageSigningEnabled=false `
            --no-restore

          if ($LASTEXITCODE -ne 0) {
            Write-Error "MSIX build failed"
            exit 1
          }
          Write-Host "MSIX build completed successfully"

      - name: Locate MSIX output
        id: msix
        shell: pwsh
        run: |
          # Look for .msixupload first (preferred for Store), then .msix
          $file = Get-ChildItem -Path "CopyPaste.UI" -Recurse -Include "*.msixupload" |
                  Select-Object -First 1

          if (-not $file) {
            $file = Get-ChildItem -Path "CopyPaste.UI" -Recurse -Include "*.msix" |
                    Select-Object -First 1
          }

          if (-not $file) {
            Write-Error "No MSIX output found"
            Write-Host "Searching build output for package files..."
            Get-ChildItem -Path "CopyPaste.UI/bin" -Recurse -File |
              Where-Object { $_.Extension -in ".msix", ".msixupload", ".appx" } |
              ForEach-Object { Write-Host $_.FullName }
            exit 1
          }

          $sizeMB = [math]::Round($file.Length / 1MB, 2)
          Write-Host "Found: $($file.FullName) ($sizeMB MB)"

          # Create a clean name for the release asset
          $ext = $file.Extension
          $cleanName = "CopyPaste-${{ steps.get_version.outputs.VERSION }}-${{ matrix.msix_arch }}$ext"
          $cleanPath = Join-Path $file.Directory.FullName $cleanName
          Copy-Item $file.FullName $cleanPath

          echo "PATH=$cleanPath" >> $env:GITHUB_OUTPUT
          echo "NAME=$cleanName" >> $env:GITHUB_OUTPUT

      - name: Upload MSIX artifact
        uses: actions/upload-artifact@v4
        with:
          name: msix-${{ matrix.msix_arch }}
          path: ${{ steps.msix.outputs.PATH }}
          retention-days: 30

      - name: Attach MSIX to GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          files: ${{ steps.msix.outputs.PATH }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # â”€â”€â”€ Microsoft Store Submission â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Automatically submits MSIX packages to the Microsoft Store.
  # Only runs on stable version tags (no pre-release).
  # Requires these GitHub secrets: STORE_TENANT_ID, STORE_CLIENT_ID, STORE_CLIENT_SECRET
  # And this GitHub variable: STORE_APP_ID
  store-publish:
    runs-on: windows-latest
    needs: store
    timeout-minutes: 15
    if: false #startsWith(github.ref, 'refs/tags/v') && !contains(github.ref, '-')

    env:
      STORE_TENANT_ID: ${{ secrets.STORE_TENANT_ID }}
      STORE_CLIENT_ID: ${{ secrets.STORE_CLIENT_ID }}
      STORE_CLIENT_SECRET: ${{ secrets.STORE_CLIENT_SECRET }}

    steps:
      - name: Check Store credentials
        id: check_creds
        shell: pwsh
        run: |
          if ([string]::IsNullOrEmpty($env:STORE_TENANT_ID) -or
              [string]::IsNullOrEmpty($env:STORE_CLIENT_ID) -or
              [string]::IsNullOrEmpty($env:STORE_CLIENT_SECRET)) {

            Write-Host "Store credentials not configured - skipping automatic submission."
            Write-Host "MSIX packages are available in the GitHub Release for manual upload."
            Write-Host ""
            Write-Host "To enable automatic Store submission, add these GitHub secrets:"
            Write-Host "  STORE_TENANT_ID     - Azure AD tenant ID"
            Write-Host "  STORE_CLIENT_ID     - Azure AD application (client) ID"
            Write-Host "  STORE_CLIENT_SECRET - Azure AD application client secret"
            Write-Host ""
            Write-Host "And this GitHub repository variable:"
            Write-Host "  STORE_APP_ID        - Partner Center application ID"
            echo "HAS_CREDS=false" >> $env:GITHUB_OUTPUT
          } else {
            Write-Host "Store credentials found - proceeding with submission"
            echo "HAS_CREDS=true" >> $env:GITHUB_OUTPUT
          }

      - name: Extract version from tag
        if: steps.check_creds.outputs.HAS_CREDS == 'true'
        id: get_version
        shell: pwsh
        run: |
          if ($env:GITHUB_REF -match 'refs/tags/v(.+)') {
            $version = $matches[1]
          } else {
            $version = "1.0.0"
          }
          echo "VERSION=$version" >> $env:GITHUB_OUTPUT

      - name: Get release notes from GitHub Release
        if: steps.check_creds.outputs.HAS_CREDS == 'true'
        id: release_notes
        shell: pwsh
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          $tag = "v${{ steps.get_version.outputs.VERSION }}"
          $headers = @{
            "Authorization" = "token $env:GH_TOKEN"
            "Accept" = "application/vnd.github.v3+json"
          }

          try {
            $release = Invoke-RestMethod `
              -Uri "https://api.github.com/repos/${{ github.repository }}/releases/tags/$tag" `
              -Headers $headers

            $body = $release.body
            if ([string]::IsNullOrWhiteSpace($body)) {
              $body = "Bug fixes and improvements."
            }

            # Store listing 'What's new' supports max 1500 characters
            if ($body.Length -gt 1500) {
              $body = $body.Substring(0, 1497) + "..."
            }

            # Write multiline output using heredoc delimiter (GitHub Actions recommended)
            $delimiter = "RELEASE_NOTES_EOF"
            echo "NOTES<<$delimiter" >> $env:GITHUB_OUTPUT
            echo $body >> $env:GITHUB_OUTPUT
            echo $delimiter >> $env:GITHUB_OUTPUT
            Write-Host "Release notes extracted ($($body.Length) chars)"
          } catch {
            Write-Warning "Failed to fetch release notes: $($_.Exception.Message)"
            echo "NOTES=Bug fixes and improvements." >> $env:GITHUB_OUTPUT
          }

      - name: Download MSIX packages
        if: steps.check_creds.outputs.HAS_CREDS == 'true'
        uses: actions/download-artifact@v4
        with:
          pattern: msix-*
          path: packages
          merge-multiple: true

      - name: Setup .NET
        if: steps.check_creds.outputs.HAS_CREDS == 'true'
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "10.0.x"
          dotnet-quality: "preview"

      - name: Install Microsoft Store CLI
        if: steps.check_creds.outputs.HAS_CREDS == 'true'
        run: dotnet tool install -g MSStore.CLI

      - name: Configure Store CLI
        if: steps.check_creds.outputs.HAS_CREDS == 'true'
        shell: pwsh
        run: |
          msstore reconfigure `
            --tenantId $env:STORE_TENANT_ID `
            --clientId $env:STORE_CLIENT_ID `
            --clientSecret $env:STORE_CLIENT_SECRET

      - name: Upload packages (without committing)
        if: steps.check_creds.outputs.HAS_CREDS == 'true'
        shell: pwsh
        run: |
          $packages = Get-ChildItem -Path packages -Include "*.msixupload","*.msix" -Recurse
          Write-Host "Uploading $($packages.Count) package(s) to Microsoft Store..."
          $packages | ForEach-Object {
            Write-Host "  - $($_.Name) ($([math]::Round($_.Length / 1MB, 2)) MB)"
          }

          if ($packages.Count -eq 0) {
            Write-Error "No MSIX packages found in packages directory"
            exit 1
          }

          # msstore publish requires a path/URL as first argument
          $firstPackage = $packages[0].FullName
          msstore publish $firstPackage --inputDirectory packages --appId ${{ vars.STORE_APP_ID }} --noCommit --verbose

      - name: Update Store listing with release notes
        if: steps.check_creds.outputs.HAS_CREDS == 'true'
        shell: pwsh
        env:
          RELEASE_NOTES: ${{ steps.release_notes.outputs.NOTES }}
        run: |
          $appId = "${{ vars.STORE_APP_ID }}"
          $notes = $env:RELEASE_NOTES

          if ([string]::IsNullOrWhiteSpace($notes)) {
            $notes = "Bug fixes and improvements."
          }

          # Escape special characters for JSON
          $escapedNotes = $notes -replace '\\', '\\\\' -replace '"', '\"' -replace "`r", '' -replace "`n", '\n'

          # Construct metadata JSON directly (PascalCase required for packaged apps)
          $metadataJson = '{"Listings":{"en-us":{"BaseListing":{"ReleaseNotes":"' + $escapedNotes + '"}}}}'

          Write-Host "Updating Store listing with release notes ($($notes.Length) chars)..."
          msstore submission updateMetadata $appId $metadataJson --skipInitialPolling
          Write-Host "Store listing metadata updated"

      - name: Commit and publish submission
        if: steps.check_creds.outputs.HAS_CREDS == 'true'
        shell: pwsh
        run: |
          Write-Host "Committing Store submission..."
          msstore submission publish ${{ vars.STORE_APP_ID }}
          Write-Host "Store submission committed - awaiting certification"
